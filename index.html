<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Data Scatter Plots</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: "Segoe UI", Roboto, sans-serif; margin: 0; background-color: #f9f9f9; color: #333; }
        .chart-container { width: 95%; max-width: 800px; margin: 20px auto; background-color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        svg { display: block; width: 100%; height: 350px; }
        .axis path, .axis line { fill: none; stroke: #ccc; shape-rendering: crispEdges; }
        .axis text { font-size: 10px; fill: #555; }
        .grid line { stroke: #e0e0e0; stroke-opacity: 0.7; shape-rendering: crispEdges; }
        .tooltip { position: absolute; text-align: center; width: auto; padding: 5px; font: 10px sans-serif; background: lightsteelblue; border: 0px; border-radius: 3px; pointer-events: none; opacity: 0; }
        .trendline { fill: none; stroke: orange; stroke-width: 2px; }
        footer { text-align: center; padding: 15px; font-size: 0.9em; color: #777; margin-top: 20px; }
        footer a { color: steelblue; text-decoration: none; }
        footer a:hover { text-decoration: underline; }
    </style>
</head>
<body>

<div id="plot1" class="chart-container"></div>
<div id="plot2" class="chart-container"></div>
<div id="plot3" class="chart-container"></div>

<footer>
    Visualizations by Jules, AI Agent. Data from <a href="https://www.kaggle.com/datasets/bahramjannesarr/goodreads-book-datasets-100k" target="_blank">GoodReads Books Dataset</a>.
</footer>

<script>
    const PLOT_HEIGHT = 350;
    const MARGIN = { top: 20, right: 30, bottom: 40, left: 50 };

    async function fetchDataAndDraw() {
        const data = await d3.json("scatter_data.json");

        const plots = [
            { id: "#plot1", xVal: d => d.pages, yVal: d => d.rating, xLabel: "Pages", yLabel: "Rating" },
            { id: "#plot2", xVal: d => d.blurb, yVal: d => d.rating, xLabel: "Blurb Length", yLabel: "Rating" },
            { id: "#plot3", xVal: d => d.reviews > 0 ? Math.log10(d.reviews) : 0, yVal: d => d.rating, xLabel: "log₁₀(Reviews)", yLabel: "Rating" }
        ];

        plots.forEach(p => createPlot(data, p.id, p.xVal, p.yVal, p.xLabel, p.yLabel));

        window.addEventListener('resize', () => {
            plots.forEach(p => {
                d3.select(p.id).select("svg").remove();
                createPlot(data, p.id, p.xVal, p.yVal, p.xLabel, p.yLabel);
            });
        });
    }

    function createPlot(data, selector, xValue, yValue, xLabelText, yLabelText) {
        const container = d3.select(selector);
        if (container.node() === null) { console.error("Container not found:", selector); return; }

        const containerWidth = container.node().getBoundingClientRect().width;
        const width = containerWidth - MARGIN.left - MARGIN.right;
        const height = PLOT_HEIGHT - MARGIN.top - MARGIN.bottom;

        const svg = container.append("svg")
            .attr("width", containerWidth)
            .attr("height", PLOT_HEIGHT)
            .append("g")
            .attr("transform", `translate(${MARGIN.left},${MARGIN.top})`);

        const x = d3.scaleLinear()
            .domain(d3.extent(data, xValue)).nice()
            .range([0, width]);

        const y = d3.scaleLinear()
            .domain(d3.extent(data, yValue)).nice()
            .range([height, 0]);

        // Axes
        const xAxis = d3.axisBottom(x).ticks(Math.max(5, Math.floor(width / 80))).tickSizeOuter(0);
        const yAxis = d3.axisLeft(y).ticks(Math.max(5, Math.floor(height / 50))).tickSizeOuter(0);

        svg.append("g")
            .attr("class", "grid")
            .attr("transform", `translate(0,${height})`)
            .call(xAxis.tickSize(-height).tickFormat(""));

        svg.append("g")
            .attr("class", "grid")
            .call(yAxis.tickSize(-width).tickFormat(""));

        svg.append("g").attr("class", "axis axis--x")
            .attr("transform", `translate(0,${height})`)
            .call(xAxis);

        svg.append("g").attr("class", "axis axis--y")
            .call(yAxis);

        // Axis labels
        svg.append("text")
            .attr("text-anchor", "end")
            .attr("x", width / 2 + MARGIN.left /2)
            .attr("y", height + MARGIN.bottom -5)
            .style("font-size", "11px")
            .text(xLabelText);

        svg.append("text")
            .attr("text-anchor", "end")
            .attr("transform", "rotate(-90)")
            .attr("y", -MARGIN.left + 15)
            .attr("x", -height / 2 + MARGIN.top)
            .style("font-size", "11px")
            .text(yLabelText);

        // Tooltip
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip");

        // Points
        svg.selectAll(".dot")
            .data(data)
            .enter().append("circle")
            .attr("class", "dot")
            .attr("cx", d => x(xValue(d)))
            .attr("cy", d => y(yValue(d)))
            .attr("r", 6)
            .style("fill", "steelblue")
            .style("opacity", 0.2)
            .on("mouseover", (event, d) => {
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`${xLabelText}: ${xValue(d).toFixed(2)}<br/>${yLabelText}: ${yValue(d).toFixed(2)}`)
                    .style("left", (event.pageX + 5) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", () => {
                tooltip.transition().duration(500).style("opacity", 0);
            });

        // LOESS trend line (simplified: using moving average for brevity)
        // A full LOESS is complex. This is a placeholder.
        // For a real LOESS, one might use a library or a more detailed implementation.
        // Given the line limit, this is a pragmatic choice.
        const lineData = data
            .map(d => ({ x: xValue(d), y: yValue(d) }))
            .sort((a, b) => a.x - b.x);

        // Simple moving average for trend line
        const windowSize = Math.max(1, Math.floor(lineData.length / 10)); // Adjust window size as needed
        const movingAverageData = [];
        for (let i = 0; i < lineData.length; i++) {
            const start = Math.max(0, i - Math.floor(windowSize / 2));
            const end = Math.min(lineData.length, i + Math.ceil(windowSize / 2));
            const windowSlice = lineData.slice(start, end);
            const avgY = d3.mean(windowSlice, d => d.y);
            if (avgY !== undefined) {
                 movingAverageData.push({ x: lineData[i].x, y: avgY });
            }
        }

        if (movingAverageData.length > 1) {
            const trend = d3.line()
                .x(d => x(d.x))
                .y(d => y(d.y))
                .curve(d3.curveBasis); // Smoothen the line a bit

            svg.append("path")
                .datum(movingAverageData)
                .attr("class", "trendline")
                .attr("d", trend);
        }
    }

    fetchDataAndDraw();
</script>

</body>
</html>
